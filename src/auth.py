import sqlite3
from datetime import datetime
import logging
import bcrypt

DATABASE_FILE = 'database.db'

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')

def hash_password(password: str) -> str:
    """Hashes a password using bcrypt."""
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

def check_password(stored_hash: str, password: str) -> bool:
    """Verifies if the password matches the stored hash."""
    return bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8'))

def register_user(name: str, email: str, password: str, role: str):
    """Registers a new user and enforces admin-only restriction."""
    if role not in ['admin', 'student']:
        raise ValueError("Invalid role specified. Must be 'admin' or 'student'.")

    try:
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()

        # Enforce single admin
        if role == "admin":
            cursor.execute('SELECT * FROM users WHERE role = "admin"')
            existing_admin = cursor.fetchone()
            if existing_admin:
                raise ValueError("An admin already exists. You cannot register another admin.")

        # Check if the email already exists
        cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
        existing_user = cursor.fetchone()
        if existing_user:
            raise ValueError("A user with this email already exists.")

        # Hash the password and insert the user
        password_hash = hash_password(password)
        cursor.execute('''INSERT INTO users (name, email, password_hash, role, suspended_until, login_attempts, blocked)
                          VALUES (?, ?, ?, ?, ?, ?, ?)''', (name, email, password_hash, role, None, 0, 0))
        conn.commit()  # Commit the transaction
        logging.info(f"User {name} registered successfully as {role}.")
    except sqlite3.Error as e:
        conn.rollback()  # Rollback on error
        logging.error(f"Database error during registration: {e}")
        raise ValueError(f"[ERROR] Database error during registration: {e}")
    finally:
        conn.close()

def login_user(email: str, password: str, role: str):
    """Authenticate a user by email, password, and role."""
    if role not in ['admin', 'student']:
        raise ValueError("Invalid role specified. Must be 'admin' or 'student'.")

    try:
        conn = sqlite3.connect(DATABASE_FILE)
        conn.row_factory = sqlite3.Row  # Enables access to rows as dictionaries
        cursor = conn.cursor()

        # Fetch user details using email
        cursor.execute('''SELECT user_id, name, email, password_hash, role, suspended_until, login_attempts, blocked
                          FROM users
                          WHERE email = ?''', (email,))
        user = cursor.fetchone()

        if not user:
            logging.warning(f"Failed login attempt: No user found with email {email}")
            raise ValueError("No user found with this email. Please check your credentials.")

        # Check if the user is blocked
        if user['blocked'] == 1:
            logging.warning(f"Account blocked for email {email}")
            raise ValueError("Your account is blocked. Please contact support.")

        # Verify the role
        if user['role'] != role:
            logging.warning(f"Failed login attempt: Role mismatch for email {email}")
            raise ValueError(f"Incorrect role. Expected: {role}, but found: {user['role']}.")
        
        # Check login attempts for student role
        if role == 'student' and user['login_attempts'] >= 2:
            logging.warning(f"Login attempt exceeded for student {email}")
            cursor.execute('UPDATE users SET blocked = 1 WHERE email = ?', (email,))
            conn.commit()
            raise ValueError("Login attempts exceeded. Account is now blocked.")

        # Verify the password
        if not check_password(user['password_hash'], password):
            # Update login attempts for students
            if role == 'student':
                cursor.execute('UPDATE users SET login_attempts = login_attempts + 1 WHERE email = ?', (email,))
                conn.commit()
            logging.warning(f"Incorrect password for email {email}")
            raise ValueError("Incorrect password. Please try again.")

        # Reset login attempts after successful login
        cursor.execute('UPDATE users SET login_attempts = 0 WHERE email = ?', (email,))
        conn.commit()

        # Check for suspension
        if user['suspended_until']:
            suspended_until = datetime.fromisoformat(user['suspended_until'])
            if datetime.now() < suspended_until:
                logging.warning(f"Account suspended for email {email} until {suspended_until}")
                raise ValueError(f"Account is suspended until {suspended_until}.")

        # Return user details
        return {
            'id': user['user_id'],
            'name': user['name'],
            'email': user['email'],
            'role': user['role'],
        }
    except sqlite3.Error as e:
        logging.error(f"Database error during login for email {email}: {e}")
        raise ValueError(f"[ERROR] Database error during login: {e}")
    finally:
        conn.close()

def unblock_user(email: str):
    """Unblocks a user and clears login attempts."""
    try:
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()

        # Check if the user exists
        cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
        user = cursor.fetchone()
        if not user:
            raise ValueError(f"No user found with email {email}.")

        # Reset login attempts and unblock user
        cursor.execute('UPDATE users SET blocked = 0, login_attempts = 0 WHERE email = ?', (email,))
        conn.commit()

        # Remove user from activity log (suspicious activity logs)
        cursor.execute('DELETE FROM activity_log WHERE email = ?', (email,))
        conn.commit()

        logging.info(f"User {email} unblocked successfully.")
    except sqlite3.Error as e:
        logging.error(f"Error unblocking user {email}: {e}")
        raise ValueError(f"[ERROR] Database error while unblocking user: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    # Example usage
    email = 'student@example.com'
    password = 'studentpassword'
    role = 'student'  # Specify the role explicitly

    try:
        user_info = login_user(email, password, role)
        print(f"[SUCCESS] Logged in as {user_info['name']} with role {user_info['role']}")
    except ValueError as e:
        print(f"[ERROR] Login failed: {e}")

    # Unblock a user example
    try:
        unblock_user('student@example.com')
    except ValueError as e:
        print(f"[ERROR] Unblock failed: {e}")
