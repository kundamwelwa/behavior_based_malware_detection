import sqlite3
import bcrypt
from datetime import datetime
import logging
from datetime import datetime, timedelta


# Configure centralized logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

DATABASE_FILE = 'database.db'
MAX_FILE_SIZE_MB = 1  # Max file size in MB
MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024

def connect_db():
    """
    Connect to the SQLite database and return the connection and cursor.
    """
    try:
        conn = sqlite3.connect(DATABASE_FILE)
        conn.row_factory = sqlite3.Row  # Make rows return as dictionaries
        cursor = conn.cursor()
        return conn, cursor
    except sqlite3.Error as e:
        logging.error(f"Error connecting to database: {e}")
        raise

def create_db():
    """
    Create necessary database tables if they don't already exist.
    """
    try:
        conn, cursor = connect_db()

        # Create 'users' table with constraints
        cursor.execute(''' 
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            role TEXT NOT NULL CHECK(role IN ('admin', 'student')),
            suspended_until DATETIME
        )
        ''')

        # Create 'user_activity_logs' table
        cursor.execute(''' 
        CREATE TABLE IF NOT EXISTS user_activity_logs (
            log_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            activity_type TEXT,  -- e.g., "login attempt", "file access", "failed login"
            timestamp DATETIME,
            suspicious BOOLEAN DEFAULT 0,  -- Flag if activity is suspicious
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )
        ''')

        # Create 'admin_actions' table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS admin_actions (
            action_id INTEGER PRIMARY KEY AUTOINCREMENT,
            admin_id INTEGER,  -- ID of the admin who took the action
            user_id INTEGER,   -- ID of the affected user
            action_type TEXT,  -- e.g., "suspend", "warn"
            timestamp DATETIME,
            FOREIGN KEY(admin_id) REFERENCES users(user_id),
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )
        ''')

        # Create 'user_files' table for file uploads
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_files (
            file_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            file_name TEXT NOT NULL,
            file_size INTEGER NOT NULL,
            upload_time DATETIME NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )
        ''')

        conn.commit()
        logging.info(f"Database and tables created successfully at '{DATABASE_FILE}'")
    except sqlite3.Error as e:
        logging.error(f"Error while creating tables: {e}")
    finally:
        if conn:
            conn.close()

def register_user(name: str, email: str, password: str, role: str):
    """
    Register a new user. Ensure only one admin exists in the database.
    Args:
        name (str): The user's full name.
        email (str): The user's email address.
        password (str): The user's password (plaintext).
        role (str): The role of the user (e.g., 'admin', 'user').
    Raises:
        ValueError: If registration fails due to role or email constraints.
    """
    try:
        conn, cursor = connect_db()

        # Check if an admin already exists
        if role.lower() == "admin":
            cursor.execute("SELECT COUNT(*) FROM users WHERE role = 'admin'")
            admin_count = cursor.fetchone()[0]
            if admin_count > 0:
                error_message = "Admin registration failed: An admin already exists in the system."
                logging.error(error_message)
                raise ValueError(error_message)

        # Check if email is already registered
        cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
        existing_user = cursor.fetchone()
        if existing_user:
            error_message = f"Registration failed: The email '{email}' is already registered."
            logging.error(error_message)
            raise ValueError(error_message)

        # Hash the password
        password_hash = bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt()).decode("utf-8")

        # Insert the new user into the database
        cursor.execute('''
        INSERT INTO users (name, email, password_hash, role, suspended_until)
        VALUES (?, ?, ?, ?, ?)
        ''', (name, email, password_hash, role.lower(), None))

        conn.commit()
        logging.info(f"User '{name}' successfully registered as '{role}'.")
    except sqlite3.Error as e:
        logging.error(f"Database error during registration: {e}")
        raise ValueError("A database error occurred. Please try again later.")
    except ValueError as ve:
        # Re-raise the error for any invalid registration constraints
        raise ve
    finally:
        if conn:
            conn.close()
            
def get_user_login_status(email: str):
    """
    Fetch the 'blocked' and 'login_attempts' columns for users with the role of 'student'.

    Args:
    - email (str): The email of the user to fetch the login status for.

    Returns:
    - dict: A dictionary containing 'blocked' and 'login_attempts' if the user is found and meets the criteria.
    - dict: Default values of 'blocked' and 'login_attempts' set to 0 if no user found or criteria not met.
    """
    try:
        conn, cursor = connect_db()

        # Log the email being queried for debugging purposes
        logging.debug(f"Fetching login status for email: {email}")

        # Query the database for users with role 'student', blocked = 1, and login_attempts = 2
        cursor.execute(
            """
            SELECT blocked, login_attempts 
            FROM users 
            WHERE email = ? AND role = 'student'
            """,
            (email,)
        )
        user = cursor.fetchone()

        logging.debug(f"Query result for {email}: {user}")

        if user:
            # Handle the tuple data, and return it as a dictionary with default values
            blocked = user[0] if user[0] is not None else 0  # Default to 0 if 'blocked' is None
            login_attempts = user[1] if user[1] is not None else 0  # Default to 0 if 'login_attempts' is None

            logging.debug(f"Blocked: {blocked}, Login Attempts: {login_attempts} for {email}")

            return {
                'blocked': blocked,
                'login_attempts': login_attempts
            }
        else:
            logging.warning(f"No student found with email: {email} or criteria not met.")
            return {
                'blocked': 0,  # Default to 0 if no user or criteria not met
                'login_attempts': 0  # Default to 0 if no user or criteria not met
            }

    except sqlite3.Error as e:
        logging.error(f"Error fetching user login status for {email}: {e}")
        return {
            'blocked': 0,  # Default to 0 in case of an error
            'login_attempts': 0  # Default to 0 in case of an error
        }
    finally:
        if conn:
            conn.close()

            
            
def remove_user_activity_log(admin_id: int, email: str, log_id: int = None, before_date: datetime = None):
    """
    Remove user activity logs based on provided parameters (including email).
    
    Args:
    - admin_id (int): The ID of the admin performing the action.
    - email (str): The email of the user whose activity logs will be removed.
    - log_id (int, optional): The ID of the specific log to remove. Defaults to None.
    - before_date (datetime, optional): Remove logs before a specific date. Defaults to None.
    
    Raises:
    - ValueError: If email is not provided or both log_id and user_id are missing.
    """
    try:
        if not email:
            raise ValueError("You must provide an email to remove activity logs.")
        
        conn, cursor = connect_db()

        # Retrieve the user_id based on the provided email
        cursor.execute("SELECT user_id FROM users WHERE email = ?", (email,))
        user = cursor.fetchone()

        if not user:
            raise ValueError(f"No user found with email: {email}")
        
        user_id = user[0]

        # Build the base query
        query = "DELETE FROM user_activity_logs WHERE user_id = ?"
        params = [user_id]

        # Filter by log_id if provided
        if log_id:
            query += " AND log_id = ?"
            params.append(log_id)

        # Filter by date if before_date is provided
        if before_date:
            query += " AND timestamp < ?"
            params.append(before_date.isoformat())  # Ensure datetime format

        # Execute the delete operation
        cursor.execute(query, params)
        conn.commit()

        # Log the action
        logging.info(f"Admin {admin_id} removed activity logs for user with email {email}, log_id={log_id}, before_date={before_date}")

    except sqlite3.Error as e:
        logging.error(f"Database error while removing activity logs: {e}")
        raise
    except ValueError as ve:
        logging.error(f"Value error: {ve}")
        raise
    finally:
        if conn:
            conn.close()

def get_all_user_emails():
    """Fetch all emails from the users table."""
    try:
        conn, cursor = connect_db()
        cursor.execute("SELECT email FROM users")  # Query to fetch all user emails
        emails = cursor.fetchall()  # This will return a list of tuples [(email1,), (email2,), ...]
        return [email[0] for email in emails]  # Return a list of email addresses
    except sqlite3.Error as e:
        logging.error(f"Error fetching user emails: {e}")
        raise
    finally:
        if conn:
            conn.close()




def get_suspicious_activities(email: str = None, activity_type: str = None, return_count: bool = True):
    """
    Retrieve suspicious activities or their count from the 'user_activity_logs' table.

    Args:
    - email (str, optional): The user's email to filter the activities. Defaults to None.
    - activity_type (str, optional): The type of activity to check for (e.g., 'login', 'password reset'). Defaults to None.
    - return_count (bool, optional): If True, return the count of suspicious activities. If False, return a list of details. Defaults to True.

    Returns:
    - int: The count of suspicious activities (if return_count=True).
    - list: A list of dictionaries containing suspicious activity details (if return_count=False).
    """
    try:
        conn, cursor = connect_db()

        # Start the query
        query = "SELECT * FROM user_activity_logs WHERE suspicious = 1"
        params = []

        # Apply filters if email and/or activity_type are provided
        if email:
            query += " AND email = ?"
            params.append(email)
        if activity_type:
            query += " AND activity_type = ?"
            params.append(activity_type)

        # Execute the query with the parameters
        cursor.execute(query, params)

        activities = cursor.fetchall()

        if return_count:
            # Return the count of suspicious activities
            return len(activities)
        else:
            # Return the list of suspicious activities as dictionaries
            return [dict(activity) for activity in activities]

    except sqlite3.Error as e:
        logging.error(f"Database error while fetching suspicious activities: {e}")
        return 0 if return_count else []
    finally:
        if conn:
            conn.close()


def log_user_activity(user_id: int, activity_type: str, email: str, suspicious: bool = False):
    """
    Log user activity into the 'user_activity_logs' table, ensuring the correct user_id is logged.
    Avoid duplicate logs for the same user_id and activity_type unless a significant time has passed.
    """
    try:
        if not user_id or user_id <= 0:
            raise ValueError(f"Invalid user_id provided: {user_id}. Activity cannot be logged.")

        conn, cursor = connect_db()

        # Fetch user details (name and email) based on user_id
        cursor.execute('SELECT name, email FROM users WHERE user_id = ?', (user_id,))
        user_data = cursor.fetchone()

        # If user is not found by user_id, fallback to using email if the login failed
        if not user_data:
            logging.warning(f"User with ID {user_id} not found. Using provided email for activity logging.")
            name = "Unknown"
            # Use the provided email directly since we don't have user data from the DB
            email = email
        else:
            name, email = user_data  # Extract name and email from the database

        # Check if the activity for this user_id already exists within the past 1 hour
        cursor.execute('''
        SELECT timestamp, suspicious FROM user_activity_logs WHERE user_id = ? AND activity_type = ?
        ''', (user_id, activity_type))
        existing_activity = cursor.fetchone()

        # Avoid logging duplicate activity unless significant time has passed (e.g., 1 hour)
        if existing_activity:
            last_logged_time = datetime.fromisoformat(existing_activity['timestamp'])  # Convert string to datetime
            time_diff = datetime.now() - last_logged_time
            if time_diff.total_seconds() < 3600:  # Skip if less than 1 hour has passed
                logging.info(f"Activity '{activity_type}' for user ID {user_id} is already logged within the last hour. Skipping.")
                return

            # If activity exists but is suspicious, make sure that the flag is consistent (if the user is blocked)
            if existing_activity['suspicious'] and suspicious:
                logging.info(f"Suspicious activity for user ID {user_id} already recorded, no further logs will be added.")
                return

        # Insert the new activity log
        cursor.execute('''
        INSERT INTO user_activity_logs (user_id, name, email, activity_type, timestamp, suspicious)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, name, email, activity_type, datetime.now().isoformat(), suspicious))

        conn.commit()
        logging.info(f"Logged activity for user ID {user_id} (Name: {name}, Email: {email}): {activity_type}, Suspicious: {suspicious}")

    except sqlite3.Error as e:
        logging.error(f"Error logging user activity: {e}")
        raise
    except ValueError as ve:
        logging.error(f"Value error: {ve}")
        raise
    finally:
        if conn:
            conn.close()
            
def unblock_user(user_email: str):
    """
    Unblocks a user by setting their 'blocked' status to 0 (not blocked) based on their email.

    Args:
    - user_email (str): The email of the user to unblock.

    Raises:
    - ValueError: If no user with the provided email exists.
    """
    try:
        conn, cursor = connect_db()

        # Fetch user_id based on email
        cursor.execute("SELECT user_id FROM users WHERE email = ?", (user_email,))
        user = cursor.fetchone()

        if not user:
            raise ValueError(f"No user found with email: {user_email}")

        # Use the user_id to unblock the user (set 'blocked' to 0)
        user_id = user[0]

        # Update the user's blocked status to 0 (unblocked)
        cursor.execute('''
            UPDATE users
            SET blocked = 0
            WHERE user_id = ?
        ''', (user_id,))
        conn.commit()

        logging.info(f"Successfully unblocked user with email: {user_email}")
    
    except sqlite3.Error as e:
        logging.error(f"Database error while unblocking user {user_email}: {e}")
        raise
    except ValueError as ve:
        logging.error(f"Value error: {ve}")
        raise
    finally:
        if conn:
            conn.close()
            
def reset_login_attempts_and_blocked_status(email: str):
    """
    Reset the 'login_attempts' and 'blocked' columns for the specific user based on the email.
    This will be executed when the admin unblocks the user.

    Args:
    - email (str): The email of the user whose login attempts and blocked status will be reset.

    Raises:
    - ValueError: If no user with the provided email exists.
    """
    conn = None
    try:
        # Establish a database connection
        conn, cursor = connect_db()

        # Fetch user_id based on the provided email
        cursor.execute("SELECT user_id FROM users WHERE email = ?", (email,))
        user = cursor.fetchone()

        if not user:
            raise ValueError(f"No user found with email: {email}")

        # Use the user_id to reset the login attempts and blocked status
        user_id = user[0]

        # Update the user's login attempts and blocked status to default values (0)
        cursor.execute('''
            UPDATE users
            SET login_attempts = 0, blocked = 0
            WHERE user_id = ? AND email = ?
        ''', (user_id, email))

        # Commit the changes to the database
        conn.commit()

        logging.info(f"Successfully reset login attempts and blocked status for user with email: {email}")
    
    except sqlite3.Error as e:
        logging.error(f"Database error while resetting login attempts and blocked status for user {email}: {e}")
        raise
    except ValueError as ve:
        logging.error(f"Value error: {ve}")
        raise
    finally:
        if conn:
            conn.close()




def log_failed_login(user_id: int, email: str):
    """
    Log a failed login attempt in the database for suspicious activity.
    Automatically suspend the user if login attempts exceed the allowed threshold.
    """
    try:
        conn, cursor = connect_db()

        # Check if there's already a failed login attempt for this email within the last 1 hour
        cursor.execute('''
        SELECT timestamp FROM user_activity_logs 
        WHERE email = ? AND activity_type = 'failed login' 
        AND timestamp >= datetime('now', '-1 hour')
        ''', (email,))
        existing_failed_attempt = cursor.fetchone()

        if existing_failed_attempt:
            logging.info(f"Failed login attempt for email {email} already logged within the last hour. Skipping.")
            return  # Skip logging if there's already a recent failed attempt

        # If user_id is valid, fetch user data
        if user_id > 0:
            cursor.execute("SELECT name, email, role FROM users WHERE user_id = ?", (user_id,))
            user_data = cursor.fetchone()
            if user_data:
                name = user_data[0]  # Get name if found
                email = user_data[1]  # Get email if found
                role = user_data[2]
            else:
                # If no user data found, log a generic entry
                name = "Unknown"
                role = None
                email = email  # Retain the provided email in the logs
        else:
            # In case user_id is invalid or not found, fallback to Unknown
            name = "Unknown"
            role = None
            email = email  # Retain the provided email in the logs

        # Log the failed login attempt
        cursor.execute(''' 
        INSERT INTO user_activity_logs (user_id, name, email, activity_type, timestamp, suspicious)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, name, email, "failed login", datetime.now(), True))

        # Count failed login attempts for this user/email
        cursor.execute('''
        SELECT COUNT(*) FROM user_activity_logs 
        WHERE email = ? AND activity_type = 'failed login' AND timestamp >= datetime('now', '-1 hour')
        ''', (email,))
        failed_attempts = cursor.fetchone()[0]

        # Automatically suspend the user if failed login attempts exceed threshold
        max_attempts = 3  # Set the maximum allowed failed login attempts
        if failed_attempts >= max_attempts:
            suspension_duration = 1  # Duration of suspension in hours
            suspended_until = (datetime.now() + timedelta(hours=suspension_duration)).isoformat()

            # Update the user's suspension status in the database
            cursor.execute('''
            UPDATE users 
            SET suspended_until = ? 
            WHERE email = ?
            ''', (suspended_until, email))
            conn.commit()

            logging.warning(f"User {email} has been suspended until {suspended_until} due to excessive failed login attempts.")

        conn.commit()
        logging.info(f"Logged failed login attempt for user {email} (ID: {user_id})")
    
    except sqlite3.Error as e:
        logging.error(f"Database error while logging failed login: {e}")
        raise
    finally:
        if conn:
            conn.close()

            
def login_user(email: str, password: str):
    """
    Handle user login and flag suspicious login attempts for students.
    Suspended users can log in only after the suspension period ends or if the admin unblocks them.
    """
    try:
        conn, cursor = connect_db()

        # Fetch the user by email
        cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
        user = cursor.fetchone()

        if not user:
            logging.warning(f"Login attempt failed. Email not found: {email}")
            log_failed_login(user_id=0, email=email)
            return False

        # Check if the user is suspended
        if user['suspended']:
            suspended_until = datetime.fromisoformat(user['suspended_until'])
            if datetime.now() < suspended_until:
                logging.warning(f"User {email} is suspended until {suspended_until}.")
                return False
            else:
                # Auto-clear suspension if the time has passed
                cursor.execute("UPDATE users SET suspended = 0, suspended_until = NULL WHERE email = ?", (email,))
                conn.commit()
                logging.info(f"Suspension for user {email} has expired. User can log in.")

        # Verify password
        if not bcrypt.checkpw(password.encode('utf-8'), user['password_hash'].encode('utf-8')):
            logging.warning(f"Invalid password for email: {email}")
            user_id = user['user_id']

            # Log failed login attempts and suspend if the threshold is exceeded
            if user['role'] == 'student':
                # Count failed login attempts in the last hour
                cursor.execute('''
                SELECT COUNT(*) FROM user_activity_logs 
                WHERE email = ? AND activity_type = 'failed login' 
                AND timestamp >= datetime('now', '-1 hour')
                ''', (email,))
                failed_attempts = cursor.fetchone()[0]

                if failed_attempts >= 3:  # Threshold for suspension
                    suspension_duration = 24  # Suspension duration in hours
                    suspended_until = (datetime.now() + timedelta(hours=suspension_duration)).isoformat()
                    cursor.execute('''
                    UPDATE users SET suspended = 1, suspended_until = ? WHERE email = ?
                    ''', (suspended_until, email))
                    conn.commit()
                    logging.warning(f"User {email} has been suspended until {suspended_until}.")
            else:
                log_user_activity(user_id, "failed login", email, suspicious=True)
            return False

        # Successful login
        user_id = user['user_id']
        logging.info(f"User {user['name']} logged in successfully.")
        log_user_activity(user_id, "login attempt", email)
        return True

    except sqlite3.Error as e:
        logging.error(f"Database error during login: {e}")
        raise
    finally:
        if conn:
            conn.close()

def get_user_by_id(user_id: int):
    """
    Retrieve a user from the database by their user ID.
    """
    try:
        conn, cursor = connect_db()

        # Fetch user information by ID
        cursor.execute(''' 
        SELECT user_id, name, email, role, suspended_until FROM users WHERE user_id = ?
        ''', (user_id,))
        user = cursor.fetchone()

        if user:
            # Return the user data as a dictionary
            return {
                "user_id": user["user_id"],
                "name": user["name"],
                "email": user["email"],
                "role": user["role"],
                "suspended_until": user["suspended_until"]
            }
        else:
            logging.warning(f"User with ID {user_id} not found.")
            return None

    except sqlite3.Error as e:
        logging.error(f"Database error while fetching user by ID: {e}")
        raise
    finally:
        if conn:
            conn.close()

def suspend_user(admin_id: int, user_id: int, suspension_time: datetime):
    """
    Suspend a user until a specific date and log the admin's action.
    """
    try:
        conn, cursor = connect_db()

        # Update the user's suspension date
        cursor.execute(''' 
        UPDATE users SET suspended_until = ? WHERE user_id = ?
        ''', (suspension_time, user_id))

        # Log the admin action
        cursor.execute(''' 
        INSERT INTO admin_actions (admin_id, user_id, action_type, timestamp)
        VALUES (?, ?, ?, ?)
        ''', (admin_id, user_id, "suspend", datetime.now()))

        conn.commit()
        logging.info(f"Admin {admin_id} suspended user {user_id} until {suspension_time}.")

    except sqlite3.Error as e:
        logging.error(f"Database error during user suspension: {e}")
        raise
    finally:
        if conn:
            conn.close()

if __name__ == "__main__":
    create_db()  # Ensure the database is created and tables are set up.
