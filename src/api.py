import bcrypt
import sqlite3
from datetime import datetime

DATABASE_FILE = 'database.db'

def hash_password(password: str) -> str:
    """Hashes a password using bcrypt."""
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

def check_password(stored_hash: str, password: str) -> bool:
    """Verifies if the password matches the stored hash."""
    return bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8'))

def register_user(name: str, email: str, password: str, role: str):
    """Registers a new user and enforces admin-only restriction."""
    if role not in ['admin', 'student']:
        raise ValueError("Invalid role specified. Must be 'admin' or 'student'.")

    try:
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()

        # Enforce single admin
        if role == "admin":
            cursor.execute('SELECT * FROM users WHERE role = "admin"')
            existing_admin = cursor.fetchone()
            if existing_admin:
                raise ValueError("An admin already exists. You cannot register another admin.")

        # Check if the email already exists
        cursor.execute('SELECT * FROM users WHERE email = ?', (email,))
        existing_user = cursor.fetchone()
        if existing_user:
            raise ValueError("A user with this email already exists.")

        # Hash the password and insert the user
        password_hash = hash_password(password)
        cursor.execute('''INSERT INTO users (name, email, password_hash, role, suspended_until)
                          VALUES (?, ?, ?, ?, ?)''', (name, email, password_hash, role, None))
        conn.commit()
        print(f"User {name} registered successfully as {role}.")
    except sqlite3.Error as e:
        raise ValueError(f"Database error during registration: {e}")
    finally:
        conn.close()

def login_user(username_or_email: str, password: str, role: str):
    """Authenticate a user by email/username and password, ensuring correct role and that role exists."""
    try:
        conn = sqlite3.connect(DATABASE_FILE)
        conn.row_factory = sqlite3.Row  # Enables access to rows as dictionaries
        cursor = conn.cursor()

        # Check if username_or_email is an email or username (not implemented, assuming email only for simplicity)
        cursor.execute('''SELECT user_id, name, email, password_hash, role, suspended_until
                          FROM users WHERE email = ?''', (username_or_email,))
        user = cursor.fetchone()

        if not user:
            raise ValueError("No user found with this email.")

        # Verify the password
        if not check_password(user['password_hash'], password):
            raise ValueError("Incorrect password. Please try again.")

        # Check for suspension
        if user['suspended_until']:
            suspended_until = datetime.fromisoformat(user['suspended_until'])
            if datetime.now() < suspended_until:
                raise ValueError(f"Account is suspended until {suspended_until}.")

        # Verify the role
        if user['role'] != role:
            raise ValueError(f"Incorrect role. Expected {role}, but found {user['role']}.")

        # Return user details, including the role, for role-based routing
        return {
            'id': user['user_id'],
            'name': user['name'],
            'email': user['email'],
            'role': user['role'],  # Role is fetched from the database
        }
    except sqlite3.Error as e:
        raise ValueError(f"Database error during login: {e}")
    finally:
        conn.close()
