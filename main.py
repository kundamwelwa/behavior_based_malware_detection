import os
import sys
import logging
from functools import wraps
import sqlite3
from flask import Flask, render_template, jsonify, request, redirect, url_for, flash, session
from werkzeug.utils import secure_filename
from src.auth import login_user, register_user
from src.admin_action import suspend_user, block_user, unblock_user
from src.behavior_model import load_model
from src.database import log_failed_login, get_suspicious_activities, get_user_by_id, reset_login_attempts_and_blocked_status, get_user_login_status, get_all_user_emails, unblock_user, update_student_fees, get_fees_paid

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

MAX_FAILED_LOGINS = 2

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("app.log"),  # Logs to a file
        logging.StreamHandler(sys.stdout)  # Logs to the console
    ]
)

app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'eb0e9c63d3ed448e6d5fd0a11fad00b32189087869386d2af452333081922331')

MODEL_PATH = 'saved_models/behavior_model.pkl'
try:
    model = load_model(MODEL_PATH)
    logging.info("Behavior detection model loaded successfully.")
except FileNotFoundError:
    logging.error(f"Model file not found at {MODEL_PATH}. Ensure the model is trained and saved.")
    model = None


@app.route('/')
def home():
    """Landing page"""
    logging.debug("Home route accessed.")
    if 'user_id' in session:
        logging.info("User logged in, redirecting to dashboard.")
        return redirect(url_for('admin_dashboard'))
    return render_template('home.html')


@app.route('/register', methods=['GET', 'POST'])
def register():
    """User registration"""
    if request.method == 'POST':
        logging.debug("Register POST request received.")
        name = request.form.get('name')
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')

        if not name or not email or not password or not role:
            logging.warning("Registration failed due to missing fields.")
            flash("All fields are required.", "danger")
            return redirect(url_for('register'))

        try:
            register_user(name=name, email=email, password=password, role=role)
            logging.info(f"User registered successfully: {email}")
            flash(f"Registration successful as {role}. Please log in.", "success")
            return redirect(url_for('login'))
        except ValueError as e:
            logging.error(f"Registration error: {e}")
            flash(f"Registration error: {e}", "danger")
        except Exception as e:
            logging.exception("Unexpected error during registration.")
            flash("An unexpected error occurred. Please try again.", "danger")
    return render_template('registration.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    """User login"""
    if request.method == 'POST':
        logging.debug("Login POST request received.")
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')

        # Validate input
        if not email or not password or not role:
            logging.warning("Login failed due to missing fields.")
            flash("Email, password, and role are required.", "danger")
            return redirect(url_for('login'))

        try:
            # Assuming login_user is a function that checks the user's credentials
            user = login_user(email=email, password=password, role=role)

            if user:  # Check if the user was found and returned
                # Check if 'blocked' key exists
                if 'blocked' in user:
                    if user['blocked'] == 1:  # Check if blocked is 1 (or True)
                        flash("Your account is blocked due to multiple failed login attempts. Please contact the admin.", "danger")
                        return redirect(url_for('login'))
                else:
                    logging.warning("The 'blocked' key is missing in the user data. Assuming not blocked.")

                session['user_id'] = user['id']
                session['role'] = user['role']
                logging.info(f"User logged in successfully: {email}, Role: {role}")
                flash(f"Welcome back, {user['name']}!", "success")

                # Redirect based on role
                if user['role'] == 'admin':
                    return redirect(url_for('admin_dashboard'))
                elif user['role'] == 'student':
                    return redirect(url_for('student_dashboard'))
                else:
                    logging.warning("Invalid role detected during login.")
                    flash("Invalid role detected. Please contact support.", "danger")
                    return redirect(url_for('logout'))
            else:
                logging.warning(f"Login attempt failed for {email}, user not found.")
                flash("Invalid email or password.", "danger")
                log_failed_login(user_id=0, email=email)  # Log failed attempt

                # Check if failed attempts exceed limit
                if get_suspicious_activities(email, 'login') > MAX_FAILED_LOGINS:
                    flash("Too many failed login attempts. Admin notified.", "danger")
                    logging.warning(f"Admin notified: Too many failed login attempts for {email}.")
                return redirect(url_for('login'))

        except ValueError as e:
            logging.error(f"Login error: {e}")
            log_failed_login(user_id=0, email=email)  # Log failed attempt when error occurs

            flash(f"Login error: {e}", "danger")
        except Exception as e:
            logging.exception("Unexpected error during login.")
            flash("An unexpected error occurred during login. Please try again.", "danger")
    return render_template('login.html')


@app.route('/admin/dashboard')
def admin_dashboard():
    """Admin dashboard"""
    logging.debug("Admin dashboard route accessed.")

    # Fetch suspicious activities as a list of details
    suspicious_activities = get_suspicious_activities(return_count=False)

    logging.debug(f"Suspicious activities fetched: {suspicious_activities}")

    if not isinstance(suspicious_activities, (list, tuple)):
        logging.error(f"Expected a list or tuple, but got {type(suspicious_activities)}")
        flash("An error occurred while fetching suspicious activities.", "danger")
        return redirect(url_for('admin_dashboard'))

    try:
        user_statuses = []

        # Fetch all user emails (you mentioned get_all_user_emails is imported)
        all_emails = get_all_user_emails()  # Fetch all user emails

        if all_emails:
            for email in all_emails:
                # Get login status for each user by email
                user_status = get_user_login_status(email)

                # If no user status is found, append default values
                if user_status is None:
                    user_status = {'blocked': 0, 'login_attempts': 0}  # Default values
                
                user_statuses.append({
                    'email': email,
                    'blocked': user_status['blocked'],
                    'login_attempts': user_status['login_attempts']
                })
        else:
            logging.warning("No users found.")

        # Log the user statuses
        logging.debug(f"User statuses fetched: {user_statuses}")

    except Exception as e:
        logging.error(f"Error fetching user data: {e}")
        flash("An error occurred while fetching user data.", "danger")
        return redirect(url_for('admin_dashboard'))

    # Pass the suspicious activities and user statuses to the template
    return render_template('admindashboard.html', suspicious_activities=suspicious_activities, user_statuses=user_statuses)




@app.route('/suspend/<email>', methods=['POST'])
def suspend_user_route(email):
    """Admin action to suspend a user"""
    try:
        # Perform suspension action using email
        suspend_user(email)
        logging.info(f"User {email} suspended successfully.")
        flash(f"User {email} has been suspended.", "success")
    except Exception as e:
        logging.error(f"Error suspending user {email}: {e}")
        flash(f"An error occurred while suspending the user: {e}", "danger")

    return redirect(url_for('admin_dashboard'))


@app.route('/block/<email>', methods=['POST'])
def block_user_route(email):
    """Admin action to block a user"""
    try:
        # Perform blocking action using email
        block_user(email)
        logging.info(f"User {email} blocked successfully.")
        flash(f"User {email} has been blocked.", "success")
    except Exception as e:
        logging.error(f"Error blocking user {email}: {e}")
        flash(f"An error occurred while blocking the user: {e}", "danger")

    return redirect(url_for('admin_dashboard'))


@app.route('/unblock/<email>', methods=['POST'])
def unblock_user_route(email):
    """Admin action to unblock a user and reset their login attempts and blocked status."""
    try:
        # Perform the unblock action using the provided email
        unblock_user(email)  # Assuming this handles unblocking the user in your system

        # Now reset the login attempts and blocked status using the email
        reset_success = reset_login_attempts_and_blocked_status(email)

        if reset_success:
            logging.info(f"User {email} unblocked and login attempts reset.")
            flash(f"User {email} has been unblocked and their login attempts have been reset.", "success")
        else:
            flash(f"Failed to reset login attempts and blocked status for {email}.", "danger")
            logging.error(f"Failed to reset login attempts and blocked status for {email}.")
            
    except Exception as e:
        # Log the error and show a flash message
        logging.error(f"Error in unblocking user {email}: {e}")
        flash(f"An error occurred while unblocking the user: {e}", "danger")

    # Redirect back to the admin dashboard
    return redirect(url_for('admin_dashboard'))


@app.route('/view_results')
def view_results():
    user_id = session.get('user_id')
    logging.info(f"User ID from session: {user_id}")
    
    # Check if user is logged in
    if not user_id:
        flash("Unauthorized access. Please log in first.", "danger")
        return redirect(url_for('login'))

    # Fetch user details from the database
    user = get_user_by_id(user_id)
    if not user:
        flash("User not found.", "danger")
        return redirect(url_for('login'))

    logging.info(f"User details: {user}")
    
    # Check if the user has paid the required fees
    fees_paid = user.get('fees_paid', 0)
    logging.info(f"Fees Paid: {fees_paid}")

    # Restrict access to results if fees are unpaid
    if fees_paid < 1500:
        flash("You must complete your fees payment to view results.", "danger")
        return redirect(url_for('student_dashboard'))

    # Sample results data (replace with real data retrieval as needed)
    results = [
        {"course_name": "Mathematics", "grade": "A", "remarks": "Excellent"},
        {"course_name": "Physics", "grade": "B", "remarks": "Good"},
        {"course_name": "Chemistry", "grade": "C", "remarks": "Satisfactory"},
    ]

    # Return the results page with user data and results
    return render_template('view_results.html', user=user, results=results)



@app.route('/update_fees', methods=['POST'])
def update_fees():
    """Admin updates a student's fees."""
    try:
        # Retrieve the email and fees_paid values from the form
        email = request.form.get('email')  # Email input by the admin
        fees_paid = int(request.form.get('fees_paid', 0))

        # Validate input to ensure no admin email mix-up
        if not email:
            raise ValueError("Student email is required.")

        # Call the database function to update fees
        update_student_fees(email, fees_paid)

        # Log and display success message
        logging.info(f"Fees updated for {email}. New amount: {fees_paid}.")
        flash(f"Fees updated for {email}.", "success")

    except ValueError as ve:
        logging.warning(str(ve))
        flash(str(ve), "warning")
    except Exception as e:
        logging.error(f"Error updating fees: {e}")
        flash("An error occurred while updating fees.", "danger")

    # Redirect back to the admin dashboard
    return redirect(url_for('admin_dashboard'))


@app.route('/check_fees_status', methods=['POST'])
def check_fees_status():
    """Check if a student's fees are fully paid."""
    try:
        # Get data from the session
        user_id = session.get('user_id')  # Ensure the user is logged in
        if not user_id:
            logging.warning("Unauthorized access attempt.")
            return jsonify({"status": "error", "message": "Unauthorized access."}), 401

        # Fetch user details from the database
        user = get_user_by_id(user_id)
        if not user:
            logging.error(f"User with ID {user_id} not found.")
            return jsonify({"status": "error", "message": "User not found."}), 404

        # Fetch fees paid from the database
        fees_paid = get_fees_paid(user_id)  # Fetch the fees paid by the user
        required_fees = 1500  # Set the required fees (adjust as needed)

        # Check if fees are fully paid
        if fees_paid >= required_fees:
            logging.info(f"User {user['name']} ({user['email']}) has fully paid fees.")
            return jsonify({"status": "success", "fees_paid": True, "message": "Fees fully paid."})
        else:
    
            admin_email = "kundamwelwa7@gmail.com" 
            logging.warning(
                f"Admin notified: User {user['name']} ({user['email']}) has unpaid fees. "
                f"Fees Paid: {fees_paid}, Required: {required_fees}"
            )
            return jsonify({
                "status": "warning",
                "fees_paid": False,
                "message": "Fees not fully paid. Admin has been notified."
            })

    except KeyError as e:
        logging.error(f"Missing key in user data: {e}")
        return jsonify({"status": "error", "message": "Missing data in the request."}), 400
    except Exception as e:
        logging.error(f"Error checking fees status: {e}")
        return jsonify({"status": "error", "message": "An error occurred while checking fees status."}), 500


@app.route('/student/dashboard')
def student_dashboard():
    """Student dashboard"""
    logging.debug("Student dashboard route accessed.")
    
    # Ensure the user is logged in and has the 'student' role
    if 'user_id' not in session or session.get('role') != 'student':
        logging.warning("Unauthorized access attempt to student dashboard.")
        flash("Unauthorized access. Students only.", "danger")
        return redirect(url_for('login'))
    
    user_id = session['user_id']
    try:
        # Fetch user details from the database
        user = get_user_by_id(user_id)
        
        # Check if the user exists
        if user:
            logging.info(f"User found: {user['name']}")
            
            # Check if the user has unpaid fees but still allow dashboard access
            if user.get('fees_paid', 0) < 1500:  # Adjust 1500 to whatever the required fee is
                logging.warning(f"User {user['name']} has unpaid fees.")
                flash("You have unpaid fees. You can view your dashboard, but you need to pay your fees to access results.", "warning")
            
            # Render the dashboard even if fees are unpaid
            return render_template('student_dashboard.html', user=user)
        else:
            logging.warning("User not found in the database.")
            flash("User not found. Please log in again.", "danger")
            return redirect(url_for('login'))
    except Exception as e:
        logging.error(f"Error fetching user data: {e}")
        flash("An error occurred while fetching user data.", "danger")
        return redirect(url_for('login'))




@app.route('/logout')
def logout():
    """Log the user out."""
    logging.debug("Logout route accessed.")
    session.pop('user_id', None)
    session.pop('role', None)
    flash("You have been logged out successfully.", "success")
    return redirect(url_for('home'))


# Error handling
@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle file size limit exceeded errors."""
    logging.warning("File size limit exceeded.")
    flash("File size exceeds the maximum allowed limit of 1MB.", "danger")
    return redirect(request.url)


if __name__ == '__main__':
    app.run(debug=True)
