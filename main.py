import os
import sys
import logging
from functools import wraps
import sqlite3
from flask import Flask, render_template, jsonify, request, redirect, url_for, flash, session
from werkzeug.utils import secure_filename
from src.auth import login_user, register_user
from src.admin_action import suspend_user, block_user, unblock_user
from src.behavior_model import load_model
from src.database import log_failed_login, get_suspicious_activities, get_user_by_id, reset_login_attempts_and_blocked_status, get_user_login_status, get_all_user_emails, unblock_user, update_student_fees, get_fees_paid, access_attempts, suspend_student, unsuspend_student, increment_access_attempts

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

MAX_FAILED_LOGINS = 2

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("app.log"),  # Logs to a file
        logging.StreamHandler(sys.stdout)  # Logs to the console
    ]
)

app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'eb0e9c63d3ed448e6d5fd0a11fad00b32189087869386d2af452333081922331')

MODEL_PATH = 'saved_models/behavior_model.pkl'
try:
    model = load_model(MODEL_PATH)
    logging.info("Behavior detection model loaded successfully.")
except FileNotFoundError:
    logging.error(f"Model file not found at {MODEL_PATH}. Ensure the model is trained and saved.")
    model = None


@app.route('/')
def home():
    """Landing page"""
    logging.debug("Home route accessed.")
    if 'user_id' in session:
        logging.info("User logged in, redirecting to dashboard.")
        return redirect(url_for('admin_dashboard'))
    return render_template('home.html')


@app.route('/register', methods=['GET', 'POST'])
def register():
    """User registration"""
    if request.method == 'POST':
        logging.debug("Register POST request received.")
        name = request.form.get('name')
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')

        if not name or not email or not password or not role:
            logging.warning("Registration failed due to missing fields.")
            flash("All fields are required.", "danger")
            return redirect(url_for('register'))

        try:
            register_user(name=name, email=email, password=password, role=role)
            logging.info(f"User registered successfully: {email}")
            flash(f"Registration successful as {role}. Please log in.", "success")
            return redirect(url_for('login'))
        except ValueError as e:
            logging.error(f"Registration error: {e}")
            flash(f"Registration error: {e}", "danger")
        except Exception as e:
            logging.exception("Unexpected error during registration.")
            flash("An unexpected error occurred. Please try again.", "danger")
    return render_template('registration.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    """User login"""
    if request.method == 'POST':
        logging.debug("Login POST request received.")
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')

        # Validate input
        if not email or not password or not role:
            logging.warning("Login failed due to missing fields.")
            flash("Email, password, and role are required.", "danger")
            return redirect(url_for('login'))

        try:
            # Assuming login_user is a function that checks the user's credentials
            user = login_user(email=email, password=password, role=role)

            if user:  # Check if the user was found and returned
                # Check if 'blocked' key exists
                if 'blocked' in user:
                    if user['blocked'] == 1:  # Check if blocked is 1 (or True)
                        flash("Your account is blocked due to multiple failed login attempts. Please contact the admin.", "danger")
                        return redirect(url_for('login'))
                else:
                    logging.warning("The 'blocked' key is missing in the user data. Assuming not blocked.")

                session['user_id'] = user['id']
                session['role'] = user['role']
                logging.info(f"User logged in successfully: {email}, Role: {role}")
                flash(f"Welcome back, {user['name']}!", "success")

                # Redirect based on role
                if user['role'] == 'admin':
                    return redirect(url_for('admin_dashboard'))
                elif user['role'] == 'student':
                    return redirect(url_for('student_dashboard'))
                else:
                    logging.warning("Invalid role detected during login.")
                    flash("Invalid role detected. Please contact support.", "danger")
                    return redirect(url_for('logout'))
            else:
                logging.warning(f"Login attempt failed for {email}, user not found.")
                flash("Invalid email or password.", "danger")
                log_failed_login(user_id=0, email=email)  # Log failed attempt

                # Check if failed attempts exceed limit
                if get_suspicious_activities(email, 'login') > MAX_FAILED_LOGINS:
                    flash("Too many failed login attempts. Admin notified.", "danger")
                    logging.warning(f"Admin notified: Too many failed login attempts for {email}.")
                return redirect(url_for('login'))

        except ValueError as e:
            logging.error(f"Login error: {e}")
            log_failed_login(user_id=0, email=email)  # Log failed attempt when error occurs

            flash(f"Login error: {e}", "danger")
        except Exception as e:
            logging.exception("Unexpected error during login.")
            flash("An unexpected error occurred during login. Please try again.", "danger")
    return render_template('login.html')


@app.route('/admin/dashboard')
def admin_dashboard():
    """Admin dashboard"""
    logging.debug("Admin dashboard route accessed.")
    
    try:
        # Fetch suspicious activities
        suspicious_activities = get_suspicious_activities(return_count=False)
        if not isinstance(suspicious_activities, (list, tuple)):
            logging.error(f"Expected a list or tuple, but got {type(suspicious_activities)}")
            flash("An error occurred while fetching suspicious activities.", "danger")
            return redirect(url_for('admin_dashboard'))

        # Fetch students who exceeded allowed access attempts
        max_allowed_attempts = 3  # Define the threshold for allowed attempts
        exceeded_students = access_attempts(max_allowed_attempts)
        logging.debug(f"Exceeded students fetched: {exceeded_students}")

        # Fetch all user login statuses, excluding admin email
        admin_email = "kundamwelwa7@gmail.com"
        user_statuses = []
        all_emails = get_all_user_emails()

        if all_emails:
            # Exclude admin email from processing
            filtered_emails = [email for email in all_emails if email != admin_email]
            
            for email in filtered_emails:
                user_status = get_user_login_status(email)
                if user_status is None:
                    user_status = {'blocked': 0, 'login_attempts': 0}  # Default values for missing users
                user_statuses.append({
                    'email': email,
                    'blocked': user_status['blocked'],
                    'login_attempts': user_status['login_attempts']
                })
        else:
            logging.warning("No users found.")

        logging.debug(f"User statuses fetched: {user_statuses}")
        
        # Render the admin dashboard with all necessary information
        return render_template(
            'admindashboard.html',
            suspicious_activities=suspicious_activities,
            exceeded_students=exceeded_students,
            user_statuses=user_statuses
        )
    
    except Exception as e:
        logging.error(f"An error occurred: {e}")
        flash("An unexpected error occurred.", "danger")
        return redirect(url_for('admin_dashboard'))




@app.route('/suspend/<email>', methods=['POST'])
def suspend_user_route(email):
    """Admin action to suspend a user"""
    try:
        # Perform suspension action using email
        suspend_user(email)
        logging.info(f"User {email} suspended successfully.")
        flash(f"User {email} has been suspended.", "success")
    except Exception as e:
        logging.error(f"Error suspending user {email}: {e}")
        flash(f"An error occurred while suspending the user: {e}", "danger")

    return redirect(url_for('admin_dashboard'))


@app.route('/block/<email>', methods=['POST'])
def block_user_route(email):
    """Admin action to block a user"""
    try:
        # Perform blocking action using email
        block_user(email)
        logging.info(f"User {email} blocked successfully.")
        flash(f"User {email} has been blocked.", "success")
    except Exception as e:
        logging.error(f"Error blocking user {email}: {e}")
        flash(f"An error occurred while blocking the user: {e}", "danger")

    return redirect(url_for('admin_dashboard'))


@app.route('/unblock/<email>', methods=['POST'])
def unblock_user_route(email):
    """Admin action to unblock a user and reset their login attempts and blocked status."""
    try:
        unblock_user(email)  
        reset_success = reset_login_attempts_and_blocked_status(email)
        if reset_success:
            logging.info(f"User {email} unblocked and login attempts reset.")
            flash(f"User {email} has been unblocked and their login attempts have been reset.", "success")
        else:
            flash(f"Failed to reset login attempts and blocked status for {email}.", "danger")
            logging.error(f"Failed to reset login attempts and blocked status for {email}.")
            
    except Exception as e:
        logging.error(f"Error in unblocking user {email}: {e}")
        flash(f"An error occurred while unblocking the user: {e}", "danger")
    return redirect(url_for('admin_dashboard'))


@app.route('/view_results')
def view_results():
    user_id = session.get('user_id')
    logging.info(f"User ID from session: {user_id}")
    
    # Check if user is logged in
    if not user_id:
        flash("Unauthorized access. Please log in first.", "danger")
        return redirect(url_for('login'))

    # Fetch user details from the database
    user = get_user_by_id(user_id)
    if not user:
        flash("User not found.", "danger")
        return redirect(url_for('login'))

    logging.info(f"User details: {user}")
    
    # Check if the user has paid the required fees
    fees_paid = user.get('fees_paid', 0)
    logging.info(f"Fees Paid: {fees_paid}")

    # Restrict access to results if fees are unpaid
    if fees_paid < 1500:
        flash("You must complete your fees payment to view results.", "danger")
        return redirect(url_for('student_dashboard'))

    # Sample results data (replace with real data retrieval as needed)
    results = [
        {"course_name": "Mathematics", "grade": "A", "remarks": "Excellent"},
        {"course_name": "Physics", "grade": "B", "remarks": "Good"},
        {"course_name": "Chemistry", "grade": "C", "remarks": "Satisfactory"},
    ]

    # Return the results page with user data and results
    return render_template('view_results.html', user=user, results=results)



@app.route('/update_fees', methods=['POST'])
def update_fees():
    """Admin updates a student's fees."""
    try:
        # Retrieve the email and fees_paid values from the form
        email = request.form.get('email')  # Email input by the admin
        fees_paid = int(request.form.get('fees_paid', 0))

        # Validate input to ensure no admin email mix-up
        if not email:
            raise ValueError("Student email is required.")

        # Call the database function to update fees
        update_student_fees(email, fees_paid)

        # Log and display success message
        logging.info(f"Fees updated for {email}. New amount: {fees_paid}.")
        flash(f"Fees updated for {email}.", "success")

    except ValueError as ve:
        logging.warning(str(ve))
        flash(str(ve), "warning")
    except Exception as e:
        logging.error(f"Error updating fees: {e}")
        flash("An error occurred while updating fees.", "danger")

    # Redirect back to the admin dashboard
    return redirect(url_for('admin_dashboard'))


@app.route('/check_fees_status', methods=['POST'])
def check_fees_status():
    """Check if a student's fees are fully paid and handle access attempts."""
    try:
        # Ensure the user is logged in
        user_id = session.get('user_id')
        if not user_id:
            logging.warning("Unauthorized access attempt.")
            return jsonify({"status": "error", "message": "Unauthorized access."}), 401
        
        # Fetch user details from the database
        user = get_user_by_id(user_id)
        if not user:
            logging.error(f"User with ID {user_id} not found.")
            return jsonify({"status": "error", "message": "User not found."}), 404
        
        # Check if the user is an admin
        if user.get('role') == 'admin':
            logging.info(f"Admin {user['email']} attempted to access student fees status.")
            return jsonify({"status": "error", "message": "Admins are not allowed to access this endpoint."}), 403
        
        # Fetch fees paid by the student
        fees_paid = get_fees_paid(user_id)
        required_fees = 1500  # Example required fees

        # Increment access attempts for the student
        access_attempts = increment_access_attempts(user['email'])
        logging.info(f"User {user['email']} has {access_attempts} access attempts.")
        
        # Logic for handling access attempts and fee status
        if access_attempts <= 2:
            if fees_paid >= required_fees:
                logging.info(f"User {user['name']} ({user['email']}) has fully paid fees.")
                return jsonify({"status": "success", "fees_paid": True, "message": "Fees fully paid. You can now view your results."})
            else:
                logging.warning(f"User {user['name']} ({user['email']}) has unpaid fees.")
                return jsonify({
                    "status": "warning",
                    "fees_paid": False,
                    "message": "Fees not fully paid. Please pay the required amount to view your results."
                })
        
        # Handle case when access attempts exceed the limit
        if access_attempts > 2:
            if fees_paid >= required_fees:
                logging.info(f"User {user['email']} exceeded access attempts but paid fees.")
                return jsonify({
                    "status": "warning",
                    "fees_paid": True,
                    "message": "You have exceeded the allowed access attempts, but you have fully paid the fees. Please contact the admin."
                })
            else:
                suspend_student(user['email'])
                logging.warning(f"User {user['email']} suspended for exceeding attempts and not paying fees.")
                return jsonify({
                    "status": "warning",
                    "fees_paid": False,
                    "message": "You have exceeded the allowed number of access attempts and have not paid the required fees. Please contact the admin."
                })

    except Exception as e:
        logging.exception(f"Error occurred in check_fees_status: {e}")
        return jsonify({"status": "error", "message": "An error occurred while processing your request."})




@app.route('/student/dashboard')
def student_dashboard():
    """Student dashboard."""
    logging.debug("Student dashboard route accessed.")
    if 'user_id' not in session or session.get('role') != 'student':
        logging.warning("Unauthorized access attempt to student dashboard.")
        flash("Unauthorized access. Students only.", "danger")
        return redirect(url_for('login'))
    user_id = session['user_id']
    try:
        user = get_user_by_id(user_id)
        if user:
            logging.info(f"User found: {user['name']}")
            
            if user.get('fees_paid', 0) < 1500:  
                logging.warning(f"User {user['name']} has unpaid fees.")
                flash("You have unpaid fees. You can view your dashboard, but you need to pay your fees to access results.", "warning")
            max_allowed_attempts = 3  
            exceeded_students = access_attempts(max_allowed_attempts)
            exceeded_status = False
            for student in exceeded_students:
                if student['user_id'] == user_id:
                    exceeded_status = True
                    flash(f"Warning: You have exceeded the allowed number of access attempts ({student['access_attempts']}).", "danger")
                    logging.warning(f"User {user['name']} ({user['email']}) exceeded access attempts.")
                    break
            return render_template(
                'student_dashboard.html', 
                user=user, 
                exceeded_status=exceeded_status
            )
        else:
            logging.warning("User not found in the database.")
            flash("User not found. Please log in again.", "danger")
            return redirect(url_for('login'))
    except Exception as e:
        logging.error(f"Error fetching user data: {e}")
        flash("An error occurred while fetching user data.", "danger")
        return redirect(url_for('login'))
    

@app.route('/suspend/<email>', methods=['POST'])
def suspend(email):
    try:
        suspend_student(email)
        return jsonify({"message": f"Student {email} suspended successfully!"}), 200
    except Exception as e:
        return jsonify({"message": str(e)}), 400

@app.route('/unsuspend/<email>', methods=['POST'])
def unsuspend(email):
    """
    Unsuspend a student by resetting their suspension status and access attempts.
    This uses the `unsuspend_student` function from the database layer.
    """
    try:
        user_emails = get_all_user_emails()
        if email not in user_emails:
            logging.error(f"API: No student found with email {email}.")
            return jsonify({"message": f"No student found with email {email}."}), 404
        unsuspend_success = unsuspend_student(email)
        if unsuspend_success:
            logging.info(f"API: Student {email} has been unsuspended successfully.")
            return jsonify({"message": f"Student {email} unsuspended successfully!"}), 200
        else:
            # Log failure and return a failure response
            logging.error(f"API: Failed to unsuspend student with email {email}. No matching record or criteria not met.")
            return jsonify({"message": f"Failed to unsuspend student with email {email}. No matching record found."}), 400

    except Exception as e:
        # Log the exception and return a failure response
        logging.error(f"API: Error unsuspending student {email}: {e}")
        return jsonify({"message": f"An error occurred: {str(e)}"}), 500

@app.route('/logout')
def logout():
    """Log the user out."""
    logging.debug("Logout route accessed.")
    session.pop('user_id', None)
    session.pop('role', None)
    flash("You have been logged out successfully.", "success")
    return redirect(url_for('home'))


# Error handling
@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle file size limit exceeded errors."""
    logging.warning("File size limit exceeded.")
    flash("File size exceeds the maximum allowed limit of 1MB.", "danger")
    return redirect(request.url)


if __name__ == '__main__':
    app.run(debug=True)
